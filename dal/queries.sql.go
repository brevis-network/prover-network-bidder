// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package dal

import (
	"context"
)

const addBid = `-- name: AddBid :exec
INSERT INTO my_bid (req_id, my_fee, bid_nonce, should_reveal_after, should_reveal_before)
VALUES ($1, $2, $3, $4, $5)
`

type AddBidParams struct {
	ReqID              string `json:"req_id"`
	MyFee              string `json:"my_fee"`
	BidNonce           string `json:"bid_nonce"`
	ShouldRevealAfter  int64  `json:"should_reveal_after"`
	ShouldRevealBefore int64  `json:"should_reveal_before"`
}

func (q *Queries) AddBid(ctx context.Context, arg AddBidParams) error {
	_, err := q.db.ExecContext(ctx, addBid,
		arg.ReqID,
		arg.MyFee,
		arg.BidNonce,
		arg.ShouldRevealAfter,
		arg.ShouldRevealBefore,
	)
	return err
}

const addProofRequest = `-- name: AddProofRequest :exec
INSERT INTO proof_request (req_id, app_id, nonce, public_values_digest, input_data, input_url, max_fee, min_stake, deadline, created_at, processed)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
`

type AddProofRequestParams struct {
	ReqID              string `json:"req_id"`
	AppID              string `json:"app_id"`
	Nonce              int64  `json:"nonce"`
	PublicValuesDigest string `json:"public_values_digest"`
	InputData          string `json:"input_data"`
	InputUrl           string `json:"input_url"`
	MaxFee             string `json:"max_fee"`
	MinStake           string `json:"min_stake"`
	Deadline           int64  `json:"deadline"`
	CreatedAt          int64  `json:"created_at"`
	Processed          bool   `json:"processed"`
}

func (q *Queries) AddProofRequest(ctx context.Context, arg AddProofRequestParams) error {
	_, err := q.db.ExecContext(ctx, addProofRequest,
		arg.ReqID,
		arg.AppID,
		arg.Nonce,
		arg.PublicValuesDigest,
		arg.InputData,
		arg.InputUrl,
		arg.MaxFee,
		arg.MinStake,
		arg.Deadline,
		arg.CreatedAt,
		arg.Processed,
	)
	return err
}

const findBidsToQueryProvingResult = `-- name: FindBidsToQueryProvingResult :many
SELECT b.req_id, b.my_fee, b.bid_nonce, b.should_reveal_after, b.should_reveal_before, b.revealed, b.bid_result, b.proof_task_id, b.proof_state, b.proof, b.proof_submit_tx, p.app_id FROM my_bid b
INNER JOIN proof_request p
ON b.req_id = p.req_id
WHERE b.proof_state = 'init' AND p.deadline > CAST(now() as BIGINT)
`

type FindBidsToQueryProvingResultRow struct {
	ReqID              string `json:"req_id"`
	MyFee              string `json:"my_fee"`
	BidNonce           string `json:"bid_nonce"`
	ShouldRevealAfter  int64  `json:"should_reveal_after"`
	ShouldRevealBefore int64  `json:"should_reveal_before"`
	Revealed           bool   `json:"revealed"`
	BidResult          string `json:"bid_result"`
	ProofTaskID        string `json:"proof_task_id"`
	ProofState         string `json:"proof_state"`
	Proof              string `json:"proof"`
	ProofSubmitTx      string `json:"proof_submit_tx"`
	AppID              string `json:"app_id"`
}

func (q *Queries) FindBidsToQueryProvingResult(ctx context.Context) ([]FindBidsToQueryProvingResultRow, error) {
	rows, err := q.db.QueryContext(ctx, findBidsToQueryProvingResult)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindBidsToQueryProvingResultRow
	for rows.Next() {
		var i FindBidsToQueryProvingResultRow
		if err := rows.Scan(
			&i.ReqID,
			&i.MyFee,
			&i.BidNonce,
			&i.ShouldRevealAfter,
			&i.ShouldRevealBefore,
			&i.Revealed,
			&i.BidResult,
			&i.ProofTaskID,
			&i.ProofState,
			&i.Proof,
			&i.ProofSubmitTx,
			&i.AppID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findBidsToSubmitProof = `-- name: FindBidsToSubmitProof :many
SELECT req_id, my_fee, bid_nonce, should_reveal_after, should_reveal_before, revealed, bid_result, proof_task_id, proof_state, proof, proof_submit_tx FROM my_bid
WHERE proof_state = 'generated'
`

func (q *Queries) FindBidsToSubmitProof(ctx context.Context) ([]MyBid, error) {
	rows, err := q.db.QueryContext(ctx, findBidsToSubmitProof)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MyBid
	for rows.Next() {
		var i MyBid
		if err := rows.Scan(
			&i.ReqID,
			&i.MyFee,
			&i.BidNonce,
			&i.ShouldRevealAfter,
			&i.ShouldRevealBefore,
			&i.Revealed,
			&i.BidResult,
			&i.ProofTaskID,
			&i.ProofState,
			&i.Proof,
			&i.ProofSubmitTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findBidsWithoutResult = `-- name: FindBidsWithoutResult :many
SELECT req_id, my_fee, bid_nonce, should_reveal_after, should_reveal_before, revealed, bid_result, proof_task_id, proof_state, proof, proof_submit_tx FROM my_bid
WHERE bid_result = '' AND should_reveal_before < $1
`

func (q *Queries) FindBidsWithoutResult(ctx context.Context, shouldRevealBefore int64) ([]MyBid, error) {
	rows, err := q.db.QueryContext(ctx, findBidsWithoutResult, shouldRevealBefore)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MyBid
	for rows.Next() {
		var i MyBid
		if err := rows.Scan(
			&i.ReqID,
			&i.MyFee,
			&i.BidNonce,
			&i.ShouldRevealAfter,
			&i.ShouldRevealBefore,
			&i.Revealed,
			&i.BidResult,
			&i.ProofTaskID,
			&i.ProofState,
			&i.Proof,
			&i.ProofSubmitTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findNotProcessedProofRequests = `-- name: FindNotProcessedProofRequests :many
SELECT p.req_id, p.app_id, p.nonce, p.public_values_digest, p.input_data, p.input_url, p.max_fee, p.min_stake, p.deadline, p.created_at, p.processed FROM proof_request p
INNER JOIN app a ON p.app_id = a.app_id
WHERE p.processed = false AND a.register_status = 'success'
`

func (q *Queries) FindNotProcessedProofRequests(ctx context.Context) ([]ProofRequest, error) {
	rows, err := q.db.QueryContext(ctx, findNotProcessedProofRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProofRequest
	for rows.Next() {
		var i ProofRequest
		if err := rows.Scan(
			&i.ReqID,
			&i.AppID,
			&i.Nonce,
			&i.PublicValuesDigest,
			&i.InputData,
			&i.InputUrl,
			&i.MaxFee,
			&i.MinStake,
			&i.Deadline,
			&i.CreatedAt,
			&i.Processed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findNotRegisteredApps = `-- name: FindNotRegisteredApps :many
SELECT app_id, img_url, register_status, register_error FROM app
WHERE register_status = ''
`

func (q *Queries) FindNotRegisteredApps(ctx context.Context) ([]App, error) {
	rows, err := q.db.QueryContext(ctx, findNotRegisteredApps)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []App
	for rows.Next() {
		var i App
		if err := rows.Scan(
			&i.AppID,
			&i.ImgUrl,
			&i.RegisterStatus,
			&i.RegisterError,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findToBeProvedBids = `-- name: FindToBeProvedBids :many
SELECT b.req_id, b.my_fee, b.bid_nonce, b.should_reveal_after, b.should_reveal_before, b.revealed, b.bid_result, b.proof_task_id, b.proof_state, b.proof, b.proof_submit_tx, p.app_id, p.input_data, p.input_url FROM my_bid b
INNER JOIN proof_request p
ON b.req_id = p.req_id
WHERE b.bid_result = 'success' AND b.proof_task_id = ''
AND p.deadline > $1
`

type FindToBeProvedBidsRow struct {
	ReqID              string `json:"req_id"`
	MyFee              string `json:"my_fee"`
	BidNonce           string `json:"bid_nonce"`
	ShouldRevealAfter  int64  `json:"should_reveal_after"`
	ShouldRevealBefore int64  `json:"should_reveal_before"`
	Revealed           bool   `json:"revealed"`
	BidResult          string `json:"bid_result"`
	ProofTaskID        string `json:"proof_task_id"`
	ProofState         string `json:"proof_state"`
	Proof              string `json:"proof"`
	ProofSubmitTx      string `json:"proof_submit_tx"`
	AppID              string `json:"app_id"`
	InputData          string `json:"input_data"`
	InputUrl           string `json:"input_url"`
}

func (q *Queries) FindToBeProvedBids(ctx context.Context, deadline int64) ([]FindToBeProvedBidsRow, error) {
	rows, err := q.db.QueryContext(ctx, findToBeProvedBids, deadline)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindToBeProvedBidsRow
	for rows.Next() {
		var i FindToBeProvedBidsRow
		if err := rows.Scan(
			&i.ReqID,
			&i.MyFee,
			&i.BidNonce,
			&i.ShouldRevealAfter,
			&i.ShouldRevealBefore,
			&i.Revealed,
			&i.BidResult,
			&i.ProofTaskID,
			&i.ProofState,
			&i.Proof,
			&i.ProofSubmitTx,
			&i.AppID,
			&i.InputData,
			&i.InputUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findToBeRevealedBid = `-- name: FindToBeRevealedBid :many
SELECT req_id, my_fee, bid_nonce, should_reveal_after, should_reveal_before, revealed, bid_result, proof_task_id, proof_state, proof, proof_submit_tx FROM my_bid
WHERE revealed = false AND ($1 > should_reveal_after AND $1 < should_reveal_before)
`

func (q *Queries) FindToBeRevealedBid(ctx context.Context, shouldRevealAfter int64) ([]MyBid, error) {
	rows, err := q.db.QueryContext(ctx, findToBeRevealedBid, shouldRevealAfter)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MyBid
	for rows.Next() {
		var i MyBid
		if err := rows.Scan(
			&i.ReqID,
			&i.MyFee,
			&i.BidNonce,
			&i.ShouldRevealAfter,
			&i.ShouldRevealBefore,
			&i.Revealed,
			&i.BidResult,
			&i.ProofTaskID,
			&i.ProofState,
			&i.Proof,
			&i.ProofSubmitTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApp = `-- name: GetApp :one
SELECT app_id, img_url, register_status, register_error
FROM app
WHERE app_id = $1
`

func (q *Queries) GetApp(ctx context.Context, appID string) (App, error) {
	row := q.db.QueryRowContext(ctx, getApp, appID)
	var i App
	err := row.Scan(
		&i.AppID,
		&i.ImgUrl,
		&i.RegisterStatus,
		&i.RegisterError,
	)
	return i, err
}

const resetAppAsNotRegister = `-- name: ResetAppAsNotRegister :exec
UPDATE app
SET register_status = ''
WHERE app_id = $1
`

func (q *Queries) ResetAppAsNotRegister(ctx context.Context, appID string) error {
	_, err := q.db.ExecContext(ctx, resetAppAsNotRegister, appID)
	return err
}

const saveApp = `-- name: SaveApp :exec
INSERT INTO app (app_id, img_url, register_status, register_error)
VALUES ($1, $2, $3, $4) ON CONFLICT DO NOTHING
`

type SaveAppParams struct {
	AppID          string `json:"app_id"`
	ImgUrl         string `json:"img_url"`
	RegisterStatus string `json:"register_status"`
	RegisterError  string `json:"register_error"`
}

func (q *Queries) SaveApp(ctx context.Context, arg SaveAppParams) error {
	_, err := q.db.ExecContext(ctx, saveApp,
		arg.AppID,
		arg.ImgUrl,
		arg.RegisterStatus,
		arg.RegisterError,
	)
	return err
}

const selectMonitorBlock = `-- name: SelectMonitorBlock :one
SELECT event, block_num, block_idx, restart 
FROM monitor_block
WHERE event = $1
`

func (q *Queries) SelectMonitorBlock(ctx context.Context, event string) (MonitorBlock, error) {
	row := q.db.QueryRowContext(ctx, selectMonitorBlock, event)
	var i MonitorBlock
	err := row.Scan(
		&i.Event,
		&i.BlockNum,
		&i.BlockIdx,
		&i.Restart,
	)
	return i, err
}

const updateAppAsRegisterFailed = `-- name: UpdateAppAsRegisterFailed :exec
UPDATE app
SET register_status = 'failed', register_error = $2
WHERE app_id = $1
`

type UpdateAppAsRegisterFailedParams struct {
	AppID         string `json:"app_id"`
	RegisterError string `json:"register_error"`
}

func (q *Queries) UpdateAppAsRegisterFailed(ctx context.Context, arg UpdateAppAsRegisterFailedParams) error {
	_, err := q.db.ExecContext(ctx, updateAppAsRegisterFailed, arg.AppID, arg.RegisterError)
	return err
}

const updateAppAsRegisterSuccess = `-- name: UpdateAppAsRegisterSuccess :exec
UPDATE app
SET register_status = 'success'
WHERE app_id = $1
`

func (q *Queries) UpdateAppAsRegisterSuccess(ctx context.Context, appID string) error {
	_, err := q.db.ExecContext(ctx, updateAppAsRegisterSuccess, appID)
	return err
}

const updateAppImgUrlAndResetStatus = `-- name: UpdateAppImgUrlAndResetStatus :exec
UPDATE app
SET register_status = '', img_url = $2
WHERE app_id = $1
`

type UpdateAppImgUrlAndResetStatusParams struct {
	AppID  string `json:"app_id"`
	ImgUrl string `json:"img_url"`
}

func (q *Queries) UpdateAppImgUrlAndResetStatus(ctx context.Context, arg UpdateAppImgUrlAndResetStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateAppImgUrlAndResetStatus, arg.AppID, arg.ImgUrl)
	return err
}

const updateBidAsProofSubmitted = `-- name: UpdateBidAsProofSubmitted :exec
UPDATE my_bid
SET proof_state = 'submitted', proof_submit_tx = $1
WHERE req_id = $2
`

type UpdateBidAsProofSubmittedParams struct {
	ProofSubmitTx string `json:"proof_submit_tx"`
	ReqID         string `json:"req_id"`
}

func (q *Queries) UpdateBidAsProofSubmitted(ctx context.Context, arg UpdateBidAsProofSubmittedParams) error {
	_, err := q.db.ExecContext(ctx, updateBidAsProofSubmitted, arg.ProofSubmitTx, arg.ReqID)
	return err
}

const updateBidAsRevealed = `-- name: UpdateBidAsRevealed :exec
UPDATE my_bid
SET revealed = true
WHERE req_id = $1
`

func (q *Queries) UpdateBidAsRevealed(ctx context.Context, reqID string) error {
	_, err := q.db.ExecContext(ctx, updateBidAsRevealed, reqID)
	return err
}

const updateBidProofTaskId = `-- name: UpdateBidProofTaskId :exec
UPDATE my_bid
SET proof_task_id = $1, proof_state = 'init'
WHERE req_id = $2
`

type UpdateBidProofTaskIdParams struct {
	ProofTaskID string `json:"proof_task_id"`
	ReqID       string `json:"req_id"`
}

func (q *Queries) UpdateBidProofTaskId(ctx context.Context, arg UpdateBidProofTaskIdParams) error {
	_, err := q.db.ExecContext(ctx, updateBidProofTaskId, arg.ProofTaskID, arg.ReqID)
	return err
}

const updateBidResult = `-- name: UpdateBidResult :exec
UPDATE my_bid
SET bid_result = $1
WHERE req_id = $2
`

type UpdateBidResultParams struct {
	BidResult string `json:"bid_result"`
	ReqID     string `json:"req_id"`
}

func (q *Queries) UpdateBidResult(ctx context.Context, arg UpdateBidResultParams) error {
	_, err := q.db.ExecContext(ctx, updateBidResult, arg.BidResult, arg.ReqID)
	return err
}

const updateBidWithProof = `-- name: UpdateBidWithProof :exec
UPDATE my_bid
SET proof = $1, proof_state = 'generated'
WHERE req_id = $2
`

type UpdateBidWithProofParams struct {
	Proof string `json:"proof"`
	ReqID string `json:"req_id"`
}

func (q *Queries) UpdateBidWithProof(ctx context.Context, arg UpdateBidWithProofParams) error {
	_, err := q.db.ExecContext(ctx, updateBidWithProof, arg.Proof, arg.ReqID)
	return err
}

const updateRequestAsProcessed = `-- name: UpdateRequestAsProcessed :exec
UPDATE proof_request
SET processed = true
WHERE req_id = $1
`

func (q *Queries) UpdateRequestAsProcessed(ctx context.Context, reqID string) error {
	_, err := q.db.ExecContext(ctx, updateRequestAsProcessed, reqID)
	return err
}

const upsertMonitorBlock = `-- name: UpsertMonitorBlock :exec
INSERT INTO monitor_block (event, block_num, block_idx, restart) 
VALUES ($1, $2, $3, $4) ON CONFLICT (event) DO
UPDATE
SET block_num = excluded.block_num,
    block_idx = excluded.block_idx,
    restart = excluded.restart
`

type UpsertMonitorBlockParams struct {
	Event    string `json:"event"`
	BlockNum int64  `json:"block_num"`
	BlockIdx int64  `json:"block_idx"`
	Restart  bool   `json:"restart"`
}

func (q *Queries) UpsertMonitorBlock(ctx context.Context, arg UpsertMonitorBlockParams) error {
	_, err := q.db.ExecContext(ctx, upsertMonitorBlock,
		arg.Event,
		arg.BlockNum,
		arg.BlockIdx,
		arg.Restart,
	)
	return err
}
